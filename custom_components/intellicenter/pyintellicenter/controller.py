"""Controller classes for Pentair Intellicenter.

This module provides three controller classes that manage communication
with the Pentair IntelliCenter system:

1. BaseController: Basic TCP connection and command handling
   - Manages connection lifecycle
   - Sends commands and correlates responses
   - Provides access to system information

2. ModelController: Extends BaseController with object model management
   - Maintains a PoolModel of equipment state
   - Tracks attribute changes via RequestParamList
   - Processes NotifyList push updates from IntelliCenter

3. ConnectionHandler: Manages reconnection logic
   - Automatic reconnection with exponential backoff
   - Debounced disconnect notifications to avoid flapping
   - Callbacks for connection state changes
"""

import asyncio
from asyncio import AbstractEventLoop, Future, Transport
from collections.abc import Callable
from hashlib import blake2b
import logging
import traceback
from typing import Any, ClassVar

from .attributes import (
    MODE_ATTR,
    OBJTYP_ATTR,
    PARENT_ATTR,
    PROPNAME_ATTR,
    SNAME_ATTR,
    SUBTYP_ATTR,
    SYSTEM_TYPE,
    VER_ATTR,
)
from .model import PoolModel
from .protocol import ICProtocol

_LOGGER = logging.getLogger(__name__)
_LOGGER.setLevel(logging.INFO)


class CommandError(Exception):
    """Represents an error in response to a Pentair request.

    Raised when the IntelliCenter responds with an error code
    other than "200" (success).
    """

    def __init__(self, errorCode: str) -> None:
        """Initialize from a Pentair errorCode.

        Args:
            errorCode: The error code string from IntelliCenter
                      (e.g., "400" for bad request).
        """
        self._errorCode = errorCode
        super().__init__(f"IntelliCenter error: {errorCode}")

    @property
    def errorCode(self) -> str:
        """Return the error code."""
        return self._errorCode


# -------------------------------------------------------------------------------------


class SystemInfo:
    """Represents minimal information about a Pentair IntelliCenter system.

    Contains basic system metadata like software version, temperature units,
    and a unique identifier derived from the system name.
    """

    # Attributes to fetch from the SYSTEM object
    ATTRIBUTES_LIST: ClassVar[list[str]] = [
        PROPNAME_ATTR,  # Property/location name
        VER_ATTR,  # Software version
        MODE_ATTR,  # Temperature units (METRIC or ENGLISH)
        SNAME_ATTR,  # System name (used to generate unique_id)
    ]

    def __init__(self, objnam: str, params: dict[str, Any]) -> None:
        """Initialize from a dictionary of system attributes.

        Args:
            objnam: The object name (e.g., "INCR" for IntelliCenter).
            params: Dictionary of system attributes fetched from IntelliCenter.
        """
        self._objnam: str = objnam
        self._propName: str = params[PROPNAME_ATTR]
        self._sw_version: str = params[VER_ATTR]
        self._mode: str = params[MODE_ATTR]

        # Generate a unique ID by hashing the system name
        # This ensures a stable identifier even if IP/hostname changes
        h = blake2b(digest_size=8)
        h.update(params[SNAME_ATTR].encode())
        self._unique_id: str = h.hexdigest()

    @property
    def propName(self) -> str:
        """Return the name of the 'property' where the system is located."""
        return self._propName

    @property
    def swVersion(self) -> str:
        """Return the software version of the IntelliCenter system."""
        return self._sw_version

    @property
    def usesMetric(self) -> bool:
        """Return True if the system uses metric units for temperature."""
        return self._mode == "METRIC"

    @property
    def uniqueID(self) -> str:
        """Return a unique identifier for this system.

        Generated by hashing the system name, ensuring stability
        across network changes.
        """
        return self._unique_id

    def update(self, updates: dict[str, Any]) -> None:
        """Update the system info from a set of key/value pairs.

        Used when attribute changes are received via NotifyList.

        Args:
            updates: Dictionary of attribute updates.
        """
        _LOGGER.debug(f"updating system info with {updates}")
        self._propName = updates.get(PROPNAME_ATTR, self._propName)
        self._sw_version = updates.get(VER_ATTR, self._sw_version)
        self._mode = updates.get(MODE_ATTR, self._mode)


# -------------------------------------------------------------------------------------


def prune(obj: Any) -> Any:
    """Cleanup a full object tree from undefined parameters.

    Pentair returns undefined parameters as key==value pairs.
    This function recursively removes such entries from dictionaries.

    Args:
        obj: The object to prune (dict, list, or primitive value)

    Returns:
        The pruned object with undefined parameters removed
    """
    # undefined meaning key == value which is what Pentair returns
    if type(obj) is list:
        return [prune(item) for item in obj]
    elif type(obj) is dict:
        result = {}
        for key, value in obj.items():
            if key != value:
                result[key] = prune(value)
        return result
    return obj


class BaseController:
    """A basic controller connecting to a Pentair system.

    This controller manages the TCP connection to the IntelliCenter and handles
    request/response correlation. It provides basic command sending capabilities
    and retrieves system information.
    """

    def __init__(
        self,
        host: str,
        port: int = 6681,
        loop: AbstractEventLoop | None = None,
    ) -> None:
        """Initialize the controller.

        Args:
            host: IP address or hostname of the IntelliCenter
            port: TCP port for connection (default: 6681)
            loop: Event loop to use (default: current event loop)
        """
        self._host = host
        self._port = port
        self._loop = loop

        self._transport: Transport | None = None
        self._protocol: ICProtocol | None = None
        self._systemInfo: SystemInfo | None = None

        self._diconnectedCallback: (
            Callable[[BaseController, Exception | None], None] | None
        ) = None

        self._requests: dict[str, Future | None] = {}

    @property
    def host(self) -> str:
        """Return the host the controller is connected to."""
        return self._host

    def connection_made(self, protocol, transport):
        """Handle the callback from the protocol."""
        _LOGGER.debug(f"Connection established to {self._host}")

    def connection_lost(self, exc):
        """Handle the callback from the protocol."""
        self.stop()  # should that be a cleanup instead?
        if self._diconnectedCallback:
            self._diconnectedCallback(self, exc)

    async def start(self) -> None:
        """Connect to the Pentair system and retrieves some system information."""
        self._transport, self._protocol = await self._loop.create_connection(
            lambda: ICProtocol(self), self._host, self._port
        )

        # we start by requesting a few attributes from the SYSTEM object
        # and therefore validate that the system connected is indeed a IntelliCenter
        msg = await self.sendCmd(
            "GetParamList",
            {
                "condition": f"{OBJTYP_ATTR}={SYSTEM_TYPE}",
                "objectList": [
                    {
                        "objnam": "INCR",
                        "keys": SystemInfo.ATTRIBUTES_LIST,
                    }
                ],
            },
        )

        info = msg["objectList"][0]
        self._systemInfo = SystemInfo(info["objnam"], info["params"])

    def stop(self):
        """Stop all activities from this controller and disconnect."""
        if self._transport:
            for request in self._requests.values():
                if request is not None:
                    request.cancel()
            self._transport.close()
            self._transport = None
            self._protocol = None

    def sendCmd(self, cmd, extra=None, waitForResponse=True) -> Future | None:
        """
        Send a command with optional extra parameters to the system.

        if waitForResponse is True, a Future is created and returned
        so either call resp = await controller.sendCmd(cmd,extra)
        or controller.sendCmd(cmd,extra,waitForResponse=False)
        """

        _LOGGER.debug(f"CONTROLLER: sendCmd: {cmd} {extra} {waitForResponse}")
        future = Future() if waitForResponse else None

        if self._protocol:
            msg_id = self._protocol.sendCmd(cmd, extra)
            self._requests[msg_id] = future
        elif future:
            future.set_exception(Exception("controller disconnected"))

        return future

    def requestChanges(
        self, objnam: str, changes: dict, waitForResponse=True
    ) -> Future:
        """Submit a change for a given object."""
        return self.sendCmd(
            "SETPARAMLIST",
            {"objectList": [{"objnam": objnam, "params": changes}]},
            waitForResponse=waitForResponse,
        )

    async def getAllObjects(self, attributeList: list):
        """Return the values of given attributes for all objects in the system."""

        result = await self.sendCmd(
            "GetParamList",
            {
                "condition": "",
                "objectList": [{"objnam": "INCR", "keys": attributeList}],
            },
        )

        # since we might have asked for more attributes than any given object
        # might define, we prune the resulting tree from these 'undefined' values
        return prune(result["objectList"])

    async def getQuery(self, queryName: str, arguments: str = ""):
        """Return the result of a Query."""
        result = await self.sendCmd(
            "GetQuery", {"queryName": queryName, "arguments": arguments}
        )
        return result["answer"]

    def getCircuitNames(self):
        """Return the list of circuit names."""
        return self.getQuery("GetCircuitNames")

    async def getCircuitTypes(self):
        """Return a dictionary: key: circuit's SUBTYP , value: 'friendly' readable string."""

        return {
            v["systemValue"]: v["readableValue"]
            for v in await self.getQuery("GetCircuitTypes")
        }

    def getHardwareDefinition(self):
        """Return the full hardware definition of the system."""
        return prune(self.getQuery("GetHardwareDefinition"))

    def getConfiguration(self):
        """Return the current 'configuration' of the system."""
        return self.getQuery("GetConfiguration")

    def receivedMessage(self, msg_id: str, command: str, response: str, msg: dict):
        """Handle the callback for a incoming message.

        msd_id is the id of the incoming message
        response is the success (200) or error code or None (if this was a notification)
        msg is the while message as a dictionary (parsing of the JSON object)
        """

        future = self._requests.pop(msg_id, 0)

        # here future can be either:
        #  - 0 if there was no corresponding request matching this response
        #      like in the case of a notification
        #  - a future is the sender of the request wanted to get the results
        #  - None is the sender declined to wait for the response (in sendCmd)

        _LOGGER.debug(
            f"CONTROLLER: receivedMessage: {msg_id} {command} {response} {future}"
        )

        if future != 0:
            if future:
                if response == "200":
                    future.set_result(msg)
                else:
                    future.set_exception(CommandError(response))
            else:
                _LOGGER.debug(f"ignoring response for msg_id {msg_id}")
        elif response is None or response == "200":
            self.processMessage(command, msg)
        else:
            _LOGGER.warning(f"CONTROLLER: error {response} : {msg}")

    def processMessage(self, command: str, msg):
        """Process a notification message."""
        pass

    @property
    def systemInfo(self):
        """Return the (cached) system information."""
        return self._systemInfo


# -------------------------------------------------------------------------------------


class ModelController(BaseController):
    """A controller creating and updating a PoolModel."""

    def __init__(self, host, model, port=6681, loop=None):
        """Initialize the controller."""
        super().__init__(host, port, loop)
        self._model: PoolModel = model

        self._updatedCallback = None

    @property
    def model(self) -> PoolModel:
        """Return the model this controller manages."""
        return self._model

    async def start(self):
        """Start the controller, fetch and start monitoring the model."""
        await super().start()

        # now we retrieve all the objects type, subtype, sname and parent
        allObjects = await self.getAllObjects(
            [OBJTYP_ATTR, SUBTYP_ATTR, SNAME_ATTR, PARENT_ATTR]
        )
        # and process that list into our model
        self.model.addObjects(allObjects)

        # _LOGGER.debug(f"objects received: {allObjects}")

        _LOGGER.info(f"model now contains {self.model.numObjects} objects")

        try:
            # now that I have my object loaded in the model
            # build a query to monitors all their relevant attributes

            attributes = self._model.attributesToTrack()

            query = []
            numAttributes = 0
            for items in attributes:
                query.append(items)
                numAttributes += len(items["keys"])
                # a query too large can choke the protocol...
                # we split them in maximum of 50 attributes (arbitrary but seems to work)
                if numAttributes >= 50:
                    res = await self.sendCmd("RequestParamList", {"objectList": query})
                    self._applyUpdates(res["objectList"])
                    query = []
                    numAttributes = 0
            # and issue the remaining elements if any
            if query:
                res = await self.sendCmd("RequestParamList", {"objectList": query})
                self._applyUpdates(res["objectList"])

        except Exception as err:
            traceback.print_exc()
            raise err

    def receivedQueryResult(self, queryName: str, answer):
        """Handle the result of all 'getQuery' responses."""

        # none are used by default
        # see Pentair protocol documentation for details
        # GetHardwareDefinition, GetConfiguration

        pass

    def _applyUpdates(self, changesAsList):
        """Apply updates received to the model."""

        updates = self._model.processUpdates(changesAsList)

        # if an update happens on the SYSTEM object
        # also applies it to our cached SystemInfo
        systemObjnam = self._systemInfo._objnam
        if systemObjnam in updates:
            self._systemInfo.update(updates[systemObjnam])

        if updates and self._updatedCallback:
            self._updatedCallback(self, updates)

        return updates

    def receivedNotifyList(self, changes):
        """Handle the notifications from IntelliCenter when tracked objects are modified."""

        try:
            # apply the changes back to the model
            self._applyUpdates(changes)

        except Exception as err:
            _LOGGER.error(f"CONTROLLER: receivedNotifyList {err}")

    def receivedWriteParamList(self, changes):
        """Handle the response to a change requested on an object."""

        try:
            self._applyUpdates(changes)

        except Exception as err:
            _LOGGER.error(f"CONTROLLER: receivedWriteParamList {err}")

    def receivedSystemConfig(self, objectList):
        """Handle the response for a request for objects."""

        _LOGGER.debug(
            f"CONTROLLER: received SystemConfig for {len(objectList)} object(s)"
        )

        # note that here we might create new objects
        self.model.addObjects(objectList)

    def processMessage(self, command: str, msg):
        """Handle the callback for an incoming message."""

        _LOGGER.debug(f"CONTROLLER: received {command} response: {msg}")

        try:
            if command == "SendQuery":
                self.receivedQueryResult(msg["queryName"], msg["answer"])
            elif command == "NotifyList":
                self.receivedNotifyList(msg["objectList"])
            elif command == "WriteParamList":
                self.receivedWriteParamList(msg["objectList"][0]["changes"])
            elif command == "SendParamList":
                self.receivedSystemConfig(msg["objectList"])
            else:
                _LOGGER.debug(f"no handler for {command}")
        except Exception as err:
            _LOGGER.error(f"error {err} while processing {msg}")
            # traceback.print_exc()


# -------------------------------------------------------------------------------------


class ConnectionHandler:
    """Helper class to recover the connect/disconnect/reconnect cycle of a controller."""

    def __init__(self, controller, timeBetweenReconnects=30, disconnectDebounceTime=15):
        """Initialize the handler.

        Args:
            controller: The controller to manage
            timeBetweenReconnects: Initial delay between reconnection attempts (default: 30s)
            disconnectDebounceTime: Grace period before marking as disconnected (default: 15s)
                This prevents rapid online/offline transitions from triggering notifications
        """
        self._controller = controller

        self._starterTask = None
        self._stopped = False
        self._firstTime = True

        self._timeBetweenReconnects = timeBetweenReconnects
        self._disconnectDebounceTime = disconnectDebounceTime
        self._disconnectDebounceTask = None
        self._isConnected = False

        controller._diconnectedCallback = self._diconnectedCallback

        if hasattr(controller, "_updatedCallback"):
            controller._updatedCallback = self.updated

    @property
    def controller(self):
        """Return the controller the handler manages."""
        return self._controller

    async def start(self):
        """Start the handler loop."""
        if not self._starterTask:
            self._starterTask = asyncio.create_task(self._starter())

    def _next_delay(self, currentDelay: int) -> int:
        """Compute the delay before the next reconnection attempt.

        default is exponential backoff with a 1.5 factor
        """
        return int(currentDelay * 1.5)

    async def _starter(self, initialDelay=0):
        """Attempt to start the controller."""
        started = False
        delay = self._timeBetweenReconnects
        while not started:
            try:
                if initialDelay:
                    self.retrying(delay)
                    await asyncio.sleep(initialDelay)
                _LOGGER.debug("trying to start controller")

                await self._controller.start()

                # Cancel any pending disconnect debounce
                if (
                    self._disconnectDebounceTask
                    and not self._disconnectDebounceTask.done()
                ):
                    self._disconnectDebounceTask.cancel()
                    self._disconnectDebounceTask = None

                if self._firstTime:
                    self.started(self._controller)
                    self._firstTime = False
                    self._isConnected = True
                else:
                    # Only call reconnected if we were previously marked as disconnected
                    if not self._isConnected:
                        self.reconnected(self._controller)
                    self._isConnected = True

                started = True
                self._starterTask = None
            except Exception as err:
                _LOGGER.error(f"cannot start: {err}")
                self.retrying(delay)
                await asyncio.sleep(delay)
                delay = self._next_delay(delay)

    def stop(self):
        """Stop the handler and the associated controller."""
        _LOGGER.debug(f"terminating connection to {self._controller.host}")
        self._stopped = True
        if self._starterTask:
            self._starterTask.cancel()
            self._starterTask = None
        if self._disconnectDebounceTask and not self._disconnectDebounceTask.done():
            self._disconnectDebounceTask.cancel()
            self._disconnectDebounceTask = None
        self._controller.stop()

    async def _delayed_disconnect_notification(self, controller, err):
        """Notify about disconnection after debounce period.

        This prevents rapid online/offline notifications when the connection
        is unstable or briefly interrupted.
        """
        try:
            await asyncio.sleep(self._disconnectDebounceTime)
            # Only notify if we're still not connected after the debounce period
            if not self._isConnected:
                _LOGGER.info(
                    f"system confirmed disconnected from {self._controller.host} "
                    f"after {self._disconnectDebounceTime}s grace period"
                )
                self.disconnected(controller, err)
        except asyncio.CancelledError:
            _LOGGER.debug("disconnect notification cancelled - system reconnected")

    def _diconnectedCallback(self, controller, err):
        """Handle the disconnection of the underlying controller."""
        if not self._stopped:
            _LOGGER.warning(
                f"system disconnected from {self._controller.host} {err if err else ''} "
                f"- waiting {self._disconnectDebounceTime}s before marking unavailable"
            )

            # Mark as disconnected immediately for internal tracking
            self._isConnected = False

            # Schedule debounced disconnect notification
            if self._disconnectDebounceTask and not self._disconnectDebounceTask.done():
                self._disconnectDebounceTask.cancel()
            self._disconnectDebounceTask = asyncio.create_task(
                self._delayed_disconnect_notification(controller, err)
            )

            # Start reconnection attempt
            self._starterTask = asyncio.create_task(
                self._starter(self._timeBetweenReconnects)
            )

    def started(self, controller):
        """Handle the first time the controller is started.

        further reconnections will trigger reconnected method instead
        """
        pass

    def retrying(self, delay):
        """Handle the fact that we will retry connection in {delay} seconds."""
        _LOGGER.info(f"will attempt to reconnect in {delay}s")

    def updated(self, controller: ModelController, updates: dict):
        """Handle the callback that our underlying system has been modified.

        only invoked if the controller has a _updatedCallback attribute
        changes is expected to contain the list of modified objects
        """
        pass

    def disconnected(self, controller, exc):
        """Handle the controller being disconnected.

        exc will contain the underlying exception except if
        the heartbeat has been missed, in this case exc is None
        """
        pass

    def reconnected(self, controller):
        """Handle the controller being reconnected.

        only occurs if the controller was connected before
        """
        pass
